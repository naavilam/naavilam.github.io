---
layout: page
permalink: /svg-gallery.html
title: SVG Gallery
description: SVGs com preview e edição no draw.io
---

<style>
    .svg-app {
        display: grid;
        grid-template-columns: 280px 1fr;
        gap: 16px;
        min-height: 65vh;
        align-items: stretch;
    }

    .svg-sidebar {
        border: 1px solid #e5e5e5;
        border-radius: 14px;
        padding: 12px;
        background: #fff;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .svg-sidebar .search {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid #d6d6d6;
        border-radius: 12px;
        outline: none;
        margin-bottom: 10px;
    }

    .svg-list {
        overflow: auto;
        padding-right: 4px;
        display: flex;
        flex-direction: column;
        gap: 6px;
    }

    .svg-item {
        border: 1px solid transparent;
        border-radius: 12px;
        padding: 10px 10px;
        cursor: pointer;
        user-select: none;
        font-family: ui-monospace, Menlo, Consolas, monospace;
        font-size: 12px;
        line-height: 1.2;
        word-break: break-all;
    }

    .svg-item:hover {
        background: #fafafa;
        border-color: #eee;
    }

    .svg-item.active {
        background: #f3f6ff;
        border-color: #cdd8ff;
    }

    .svg-main {
        border: 1px solid #e5e5e5;
        border-radius: 14px;
        background: #fff;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .svg-toolbar {
        padding: 10px 12px;
        border-bottom: 1px solid #eee;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
        justify-content: space-between;
    }

    .svg-title {
        font-family: ui-monospace, Menlo, Consolas, monospace;
        font-size: 12px;
        word-break: break-all;
        opacity: 0.9;
    }

    .svg-actions {
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .btn {
        border: 1px solid #d6d6d6;
        background: #fff;
        border-radius: 12px;
        padding: 8px 10px;
        font-size: 12px;
        cursor: pointer;
        text-decoration: none;
        color: inherit;
        white-space: nowrap;
    }

    .btn:hover {
        background: #fafafa;
    }

    /* Área de visualização (o botão fica fora dela, na toolbar acima) */
    .svg-view {
        flex: 1;
        min-height: 450px;
        background: #fafafa;
        position: relative;
        overflow: auto;
        padding: 18px;
    }

    .svg-canvas {
        border: 1px dashed #d0d0d0;
        border-radius: 14px;
        background: #fff;
        padding: 14px;
        min-height: 100%;
    }

    /* Faz o SVG caber bem */
    .svg-canvas svg {
        width: 100%;
        height: auto;
        display: block;
    }

    .hint {
        opacity: 0.7;
        font-size: 13px;
        padding: 8px 0 0;
    }

    @media (max-width: 900px) {
        .svg-app {
            grid-template-columns: 1fr;
        }

        .svg-view {
            min-height: 360px;
        }
    }

    /* Tree view */
    .svg-list {
        overflow: auto;
        padding-right: 4px;
        display: flex;
        flex-direction: column;
        gap: 4px;
    }

    /* linha (dir ou file) */
    .tree-row {
        border: 1px solid transparent;
        border-radius: 12px;
        padding: 8px 10px;
        cursor: pointer;
        user-select: none;
        font-family: ui-monospace, Menlo, Consolas, monospace;
        font-size: 12px;
        line-height: 1.2;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .tree-row:hover {
        background: #fafafa;
        border-color: #eee;
    }

    .tree-row.active {
        background: #f3f6ff;
        border-color: #cdd8ff;
    }

    .tree-icon {
        width: 16px;
        text-align: center;
        opacity: 0.85;
    }

    .tree-name {
        flex: 1;
        word-break: break-all;
    }

    /* indentação por nível */
    .tree-indent {
        margin-left: var(--indent, 0px);
    }

    /* container de filhos */
    .tree-children {
        margin-top: 2px;
        display: flex;
        flex-direction: column;
        gap: 4px;
    }
</style>

<div class="svg-app">
    <aside class="svg-sidebar">
        <input id="q" class="search" placeholder="filtrar por nome…" />
        <div id="list" class="svg-list"></div>
    </aside>

    <section class="svg-main">
        <div class="svg-toolbar">
            <div class="svg-title" id="title">Selecione um SVG à esquerda</div>
            <div class="svg-actions">
                <a id="openRaw" class="btn" href="#" target="_blank" rel="noopener" style="display:none;">Abrir SVG</a>
                <a id="editDrawio" class="btn" href="#" target="_blank" rel="noopener" style="display:none;">Editar</a>
            </div>
        </div>

        <div class="svg-view">
            <div id="canvas" class="svg-canvas">
                <div class="hint">Clique em um arquivo na lista para visualizar aqui.</div>
            </div>
        </div>
    </section>

</div>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script>
(async () => {
  const BASE = "{{ site.baseurl }}";

  const listEl   = document.getElementById("list");
  const qEl      = document.getElementById("q");
  const titleEl  = document.getElementById("title");
  const canvasEl = document.getElementById("canvas");
  const openRawEl= document.getElementById("openRaw");
  const editEl   = document.getElementById("editDrawio");

  // cache-buster pra evitar Pages/CDN te devolver index velho
  const indexUrl = `${BASE}/assets/svg/index.json?v=${Date.now()}`;
  const res = await fetch(indexUrl, { cache: "no-store" });
  if (!res.ok) {
    canvasEl.innerHTML = `<div class="hint">Não consegui carregar ${indexUrl} (status ${res.status}).</div>`;
    return;
  }

  // >>> seu index AGORA é árvore (type/children)
  const tree = await res.json(); // root {type:"dir", children:[...]}

  // Estado da UI
  let currentPath = null;           // ex: "workflows/pages.svg"
  const expanded = new Set();       // paths de dirs abertos: "workflows", "scripts", etc.

  // abre tudo por padrão? (opcional)
  // tree.children?.forEach(d => { if (d.type === "dir") expanded.add(d.path); });

  function u8ToB64Url(u8) {
    let s = "";
    const chunk = 0x8000;
    for (let i = 0; i < u8.length; i += chunk) {
      s += String.fromCharCode.apply(null, u8.subarray(i, i + chunk));
    }
    return btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }

  function mermaidLiveEditUrl(mmdText) {
    const state = {
      code: mmdText,
      mermaid: { theme: "default" },
      autoSync: true,
      updateDiagram: true,
      editorMode: "code",
      panZoom: true,
      zoom: 1
    };

    if (!window.pako) throw new Error("pako não carregou (cdn).");

    const json = JSON.stringify(state);
    const compressed = window.pako.deflate(json);
    const payload = u8ToB64Url(compressed);
    return `https://mermaid.live/edit#pako:${payload}`;
  }

  function svgFetchUrl(relPath) {
    // relPath: "workflows/pages.svg"
    return `${BASE}/assets/svg/${relPath}?v=${Date.now()}`;
  }

  function svgRawUrl(relPath) {
    return `${BASE}/assets/svg/${relPath}`;
  }

  function mmdUrlFromSvg(relSvgPath) {
    // "workflows/pages.svg" -> "workflows/pages.mmd"
    const base = relSvgPath.replace(/\.svg$/i, "");
    return `${BASE}/assets/mmd/${base}.mmd`;
  }

  function drawioCdnUrlFromSvg(relSvgPath) {
    // "arquitetura/draw1.svg" -> CDN ".../assets/drawio/arquitetura/draw1.drawio"
    const base = relSvgPath.replace(/\.svg$/i, "");

    // ajuste se mudar repo/branch no futuro
    const owner = "naavilam";
    const repo  = "naavilam.github.io";
    const branch= "main";

    return `https://cdn.jsdelivr.net/gh/${owner}/${repo}@${branch}/assets/drawio/${base}.drawio`;
  }

  // -----------------------------
  // Filter: mantém árvore relevante
  // -----------------------------
  function filterTree(node, qLower) {
    if (!qLower) return node;

    if (node.type === "file") {
      const hit = (node.name || "").toLowerCase().includes(qLower) ||
                  (node.path || "").toLowerCase().includes(qLower);
      return hit ? node : null;
    }

    // dir
    const kids = (node.children || [])
      .map(ch => filterTree(ch, qLower))
      .filter(Boolean);

    // mantém dir se ele bate no nome OU se algum filho sobrou
    const dirHit = (node.name || "").toLowerCase().includes(qLower);
    if (dirHit || kids.length) {
      return { ...node, children: kids };
    }
    return null;
  }

  // -----------------------------
  // Render Tree
  // -----------------------------
  function renderTree(node, depth = 0) {
    const container = document.createElement("div");
    container.className = "tree-children";

    for (const child of (node.children || [])) {
      const row = document.createElement("div");
      row.className = "tree-row tree-indent";
      row.style.setProperty("--indent", `${depth * 14}px`);

      const icon = document.createElement("div");
      icon.className = "tree-icon";

      const name = document.createElement("div");
      name.className = "tree-name";
      name.textContent = child.name;

      if (child.type === "dir") {
        const isOpen = expanded.has(child.path);
        icon.textContent = isOpen ? "▾" : "▸";

        row.addEventListener("click", () => {
          if (expanded.has(child.path)) expanded.delete(child.path);
          else expanded.add(child.path);
          renderList(); // re-render
        });

        row.appendChild(icon);
        row.appendChild(name);
        container.appendChild(row);

        if (isOpen) {
          container.appendChild(renderTree(child, depth + 1));
        }
      } else {
        icon.textContent = "•";

        if (child.path === currentPath) row.classList.add("active");

        row.addEventListener("click", () => load(child.path));

        row.appendChild(icon);
        row.appendChild(name);
        container.appendChild(row);
      }
    }

    return container;
  }

  function autoExpandForMatches(filteredRoot) {
    // abre automaticamente diretórios que têm filhos após filtro
    function walk(n) {
      if (n.type === "dir") {
        if ((n.children || []).length) {
          expanded.add(n.path || ""); // root path "" ok
          for (const ch of n.children) walk(ch);
        }
      }
    }
    expanded.clear();
    walk(filteredRoot);
  }

  function renderList() {
    const q = (qEl.value || "").trim().toLowerCase();
    listEl.innerHTML = "";

    const filtered = filterTree(tree, q);

    if (!filtered || !(filtered.children || []).length) {
      const empty = document.createElement("div");
      empty.className = "hint";
      empty.textContent = "Nenhum arquivo encontrado.";
      listEl.appendChild(empty);
      return;
    }

    // se estiver filtrando, abre tudo que tiver match para ficar usável
    if (q) autoExpandForMatches(filtered);

    listEl.appendChild(renderTree(filtered, 0));
  }

  // -----------------------------
  // Load SVG + set Edit button
  // -----------------------------
  async function load(relSvgPath) {
    currentPath = relSvgPath;
    renderList();

    titleEl.textContent = relSvgPath;

    // link "Abrir SVG"
    openRawEl.style.display = "";
    openRawEl.href = svgRawUrl(relSvgPath);

    // reset botão Editar
    editEl.style.display = "none";
    editEl.href = "#";
    editEl.target = "_blank";
    editEl.rel = "noopener";
    editEl.textContent = "";

    // 1) Mermaid (mmd com mesmo path)
    const mmdUrl = mmdUrlFromSvg(relSvgPath);

    try {
      const rMmd = await fetch(`${mmdUrl}?v=${Date.now()}`, { cache: "no-store" });
      if (!rMmd.ok) throw new Error(`HTTP ${rMmd.status}`);

      const code = await rMmd.text();
      editEl.href = mermaidLiveEditUrl(code);
      editEl.textContent = "Editar no Mermaid Live";
      editEl.style.display = "";
    } catch (e) {
      // 2) Draw.io via CDN + provider GitHub (que agora funciona)
      const drawioCdn = drawioCdnUrlFromSvg(relSvgPath);
      editEl.href = `https://app.diagrams.net/?url=${encodeURIComponent(drawioCdn)}`;
      editEl.textContent = "Editar no draw.io";
      editEl.style.display = "";
    }

    // preview do SVG
    canvasEl.innerHTML = `<div class="hint">carregando…</div>`;
    try {
      const r = await fetch(svgFetchUrl(relSvgPath), { cache: "no-store" });
      if (!r.ok) throw new Error(`HTTP ${r.status}`);

      const svgText = await r.text();
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      const svgEl = doc.documentElement;

      if (!svgEl || svgEl.tagName.toLowerCase() !== "svg") {
        const pe = doc.querySelector("parsererror");
        const msg = pe ? pe.textContent : "conteúdo não é um <svg> válido";
        throw new Error(`SVG inválido: ${msg}`);
      }

      canvasEl.innerHTML = "";
      canvasEl.appendChild(document.importNode(svgEl, true));
    } catch (e) {
      canvasEl.innerHTML = `<div class="hint">falhou ao carregar o SVG: ${String(e)}</div>`;
      console.error(e);
    }
  }

  // Events
  qEl.addEventListener("input", renderList);

  // Inicializa
  // abre pastas top-level por padrão (fica bonito)
  for (const ch of (tree.children || [])) {
    if (ch.type === "dir") expanded.add(ch.path);
  }

  renderList();

  // auto-abrir o primeiro arquivo encontrado (DFS)
  function firstFile(n) {
    if (n.type === "file") return n.path;
    for (const ch of (n.children || [])) {
      const f = firstFile(ch);
      if (f) return f;
    }
    return null;
  }
  const first = firstFile(tree);
  if (first) load(first);

})();
</script>